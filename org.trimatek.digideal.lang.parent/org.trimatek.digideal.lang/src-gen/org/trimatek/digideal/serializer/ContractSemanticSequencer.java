/*
 * generated by Xtext 2.13.0
 */
package org.trimatek.digideal.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.trimatek.digideal.contract.AllFacts;
import org.trimatek.digideal.contract.AnyFact;
import org.trimatek.digideal.contract.Contract;
import org.trimatek.digideal.contract.ContractPackage;
import org.trimatek.digideal.contract.Facts;
import org.trimatek.digideal.contract.FactsLevel;
import org.trimatek.digideal.contract.PayTo;
import org.trimatek.digideal.contract.PaymentCondition;
import org.trimatek.digideal.contract.Reference;
import org.trimatek.digideal.contract.Sentence;
import org.trimatek.digideal.contract.Subject;
import org.trimatek.digideal.contract.SupervisedBy;
import org.trimatek.digideal.services.ContractGrammarAccess;

@SuppressWarnings("all")
public class ContractSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ContractGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ContractPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ContractPackage.ALL_FACTS:
				sequence_AllFacts(context, (AllFacts) semanticObject); 
				return; 
			case ContractPackage.ANY_FACT:
				sequence_AnyFact(context, (AnyFact) semanticObject); 
				return; 
			case ContractPackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case ContractPackage.FACTS:
				sequence_Facts(context, (Facts) semanticObject); 
				return; 
			case ContractPackage.FACTS_LEVEL:
				sequence_FactsLevel(context, (FactsLevel) semanticObject); 
				return; 
			case ContractPackage.PAY_TO:
				sequence_PayTo(context, (PayTo) semanticObject); 
				return; 
			case ContractPackage.PAYMENT_CONDITION:
				sequence_PaymentCondition(context, (PaymentCondition) semanticObject); 
				return; 
			case ContractPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case ContractPackage.SENTENCE:
				sequence_Sentence(context, (Sentence) semanticObject); 
				return; 
			case ContractPackage.SUBJECT:
				sequence_Subject(context, (Subject) semanticObject); 
				return; 
			case ContractPackage.SUPERVISED_BY:
				sequence_SupervisedBy(context, (SupervisedBy) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AllFacts returns AllFacts
	 *
	 * Constraint:
	 *     value='demostrable con TODOS los siguientes hechos:'
	 */
	protected void sequence_AllFacts(ISerializationContext context, AllFacts semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.ALL_FACTS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.ALL_FACTS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAllFactsAccess().getValueDemostrableConTODOSLosSiguientesHechosKeyword_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AnyFact returns AnyFact
	 *
	 * Constraint:
	 *     value='demostrable con CUALQUIERA de los siguientes hechos:'
	 */
	protected void sequence_AnyFact(ISerializationContext context, AnyFact semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.ANY_FACT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.ANY_FACT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnyFactAccess().getValueDemostrableConCUALQUIERADeLosSiguientesHechosKeyword_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     (cid=ID paragraph+=Sentence*)
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FactsLevel returns FactsLevel
	 *
	 * Constraint:
	 *     (options=AnyFact | options=AllFacts)
	 */
	protected void sequence_FactsLevel(ISerializationContext context, FactsLevel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Facts returns Facts
	 *
	 * Constraint:
	 *     (fact+=STRING fact+=STRING*)
	 */
	protected void sequence_Facts(ISerializationContext context, Facts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns PayTo
	 *     PayTo returns PayTo
	 *
	 * Constraint:
	 *     (payer=[Subject|ID] collector=[Subject|ID] sts=INT)
	 */
	protected void sequence_PayTo(ISerializationContext context, PayTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.PAY_TO__PAYER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.PAY_TO__PAYER));
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.PAY_TO__COLLECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.PAY_TO__COLLECTOR));
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.PAY_TO__STS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.PAY_TO__STS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPayToAccess().getPayerSubjectIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ContractPackage.Literals.PAY_TO__PAYER, false));
		feeder.accept(grammarAccess.getPayToAccess().getCollectorSubjectIDTerminalRuleCall_3_1_0_1(), semanticObject.eGet(ContractPackage.Literals.PAY_TO__COLLECTOR, false));
		feeder.accept(grammarAccess.getPayToAccess().getStsINTTerminalRuleCall_5_0(), semanticObject.getSts());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns PaymentCondition
	 *     PaymentCondition returns PaymentCondition
	 *
	 * Constraint:
	 *     (collector=[Subject|ID] description=STRING level=FactsLevel facts=Facts)
	 */
	protected void sequence_PaymentCondition(ISerializationContext context, PaymentCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.PAYMENT_CONDITION__COLLECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.PAYMENT_CONDITION__COLLECTOR));
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.PAYMENT_CONDITION__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.PAYMENT_CONDITION__DESCRIPTION));
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.PAYMENT_CONDITION__LEVEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.PAYMENT_CONDITION__LEVEL));
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.PAYMENT_CONDITION__FACTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.PAYMENT_CONDITION__FACTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPaymentConditionAccess().getCollectorSubjectIDTerminalRuleCall_1_1_0_1(), semanticObject.eGet(ContractPackage.Literals.PAYMENT_CONDITION__COLLECTOR, false));
		feeder.accept(grammarAccess.getPaymentConditionAccess().getDescriptionSTRINGTerminalRuleCall_2_0(), semanticObject.getDescription());
		feeder.accept(grammarAccess.getPaymentConditionAccess().getLevelFactsLevelParserRuleCall_3_0(), semanticObject.getLevel());
		feeder.accept(grammarAccess.getPaymentConditionAccess().getFactsFactsParserRuleCall_4_0(), semanticObject.getFacts());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns Reference
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     type=[Subject|ID]
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.REFERENCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.REFERENCE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceAccess().getTypeSubjectIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ContractPackage.Literals.REFERENCE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns Sentence
	 *
	 * Constraint:
	 *     sentenceType=STRING
	 */
	protected void sequence_Sentence(ISerializationContext context, Sentence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.SENTENCE__SENTENCE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.SENTENCE__SENTENCE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSentenceAccess().getSentenceTypeSTRINGTerminalRuleCall_0_0(), semanticObject.getSentenceType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns Subject
	 *     Subject returns Subject
	 *
	 * Constraint:
	 *     (name=ID address=STRING email=Email)
	 */
	protected void sequence_Subject(ISerializationContext context, Subject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.SUBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.SUBJECT__NAME));
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.SUBJECT__ADDRESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.SUBJECT__ADDRESS));
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.SUBJECT__EMAIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.SUBJECT__EMAIL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubjectAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSubjectAccess().getAddressSTRINGTerminalRuleCall_3_0(), semanticObject.getAddress());
		feeder.accept(grammarAccess.getSubjectAccess().getEmailEmailParserRuleCall_5_0(), semanticObject.getEmail());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns SupervisedBy
	 *     SupervisedBy returns SupervisedBy
	 *
	 * Constraint:
	 *     agent=Subject
	 */
	protected void sequence_SupervisedBy(ISerializationContext context, SupervisedBy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ContractPackage.Literals.SUPERVISED_BY__AGENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ContractPackage.Literals.SUPERVISED_BY__AGENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSupervisedByAccess().getAgentSubjectParserRuleCall_1_0(), semanticObject.getAgent());
		feeder.finish();
	}
	
	
}
